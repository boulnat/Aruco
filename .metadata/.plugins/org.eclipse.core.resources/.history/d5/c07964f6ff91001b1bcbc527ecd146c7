/*
 * AS7341.c
 *
 *  Created on: Mar 30, 2021
 *      Author: boulnat
 */
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <main.h>
#include <AS7341.h>

uint16_t readChannel(I2C_HandleTypeDef *hi2c1, as7341_adc_channel_t channel) {

	uint8_t read[2];
	uint16_t read16bits = 0;
	uint8_t regCh[] = {0x61,0x62};
	uint8_t data[] = {0xA9, 0x08};
	//uint8_t data[] = {0x80, 0x01};
	while(HAL_I2C_Master_Transmit(hi2c1, 0x72, data, sizeof(data), HAL_MAX_DELAY) != HAL_OK);
	while(HAL_I2C_IsDeviceReady(hi2c1,0x72,10,200)!=HAL_OK);


	while(HAL_I2C_Master_Transmit(hi2c1, 0x72, regCh, 2, HAL_MAX_DELAY) != HAL_OK);
	while(HAL_I2C_IsDeviceReady(hi2c1,0x72,10,200)!=HAL_OK);
	while(HAL_I2C_Master_Receive(hi2c1, 0x72, read, sizeof(read), HAL_MAX_DELAY)!= HAL_OK);


	read16bits = (read[0] << 8) | read[1];
	return read16bits;

}

uint16_t getChannel(as7341_color_channel_t channel) {
  return _channel_readings[channel];
}

bool readAllChannels(I2C_HandleTypeDef *hi2c1,uint16_t *readings_buffer) {

	setSMUXLowChannels(true);        // Configure SMUX to read low channels
  	enableSpectralMeasurement(true); // Start integration
  	delayForData(0);                 // I'll wait for you for all time

	uint8_t read[2];
	uint16_t read16bits = 0;
	uint8_t regCh[] = {AS7341_CH0_DATA_L};
	uint8_t data[] = {0xA9, 0x08};

	while(HAL_I2C_Master_Transmit(hi2c1, 0x72, regCh, sizeof(regCh), HAL_MAX_DELAY) != HAL_OK);
	while(HAL_I2C_IsDeviceReady(hi2c1,0x72,10,200)!=HAL_OK);
	while(HAL_I2C_Master_Receive(hi2c1, 0x73, read, sizeof(read), HAL_MAX_DELAY)!= HAL_OK);

  Adafruit_BusIO_Register channel_data_reg =
      Adafruit_BusIO_Register(i2c_dev, AS7341_CH0_DATA_L, 2);

  bool low_success = channel_data_reg.read((uint8_t *)readings_buffer, 12);

  setSMUXLowChannels(false);       // Configure SMUX to read high channels
  enableSpectralMeasurement(true); // Start integration
  delayForData(0);                 // I'll wait for you for all time

  return low_success &&
         channel_data_reg.read((uint8_t *)&readings_buffer[6], 12);
}

void setSMUXLowChannels(I2C_HandleTypeDef *hi2c1, bool f1_f4) {
  enableSpectralMeasurement(false);
  setSMUXCommand(AS7341_SMUX_CMD_WRITE);
  if (f1_f4) {
    setup_F1F4_Clear_NIR();
  } else {
    //setup_F5F8_Clear_NIR();
  }
  enableSMUX();
}

bool setSMUXCommand(I2C_HandleTypeDef *hi2c1 ,as7341_smux_cmd_t command) {

	uint8_t regCh[] = {0xAF,0x08, command};

	while(HAL_I2C_Master_Transmit(hi2c1, 0x72, regCh, sizeof(regCh), HAL_MAX_DELAY) != HAL_OK);
	while(HAL_I2C_IsDeviceReady(hi2c1,0x72,10,200)!=HAL_OK);

  return 1;
}

bool enableSpectralMeasurement(I2C_HandleTypeDef *hi2c1, bool enable_measurement) {

	uint8_t regCh[] = {0x80, 0x08};
	while(HAL_I2C_Master_Transmit(hi2c1, 0x72, regCh, sizeof(regCh), HAL_MAX_DELAY) != HAL_OK);
	while(HAL_I2C_IsDeviceReady(hi2c1,0x72,10,200)!=HAL_OK);

  return 1;
}
bool enableSMUX(I2C_HandleTypeDef *hi2c1, void) {

	uint8_t regCh[] = {0x80, 0x10};
	while(HAL_I2C_Master_Transmit(hi2c1, 0x72, regCh, sizeof(regCh), HAL_MAX_DELAY) != HAL_OK);
	while(HAL_I2C_IsDeviceReady(hi2c1,0x72,10,200)!=HAL_OK);

    return 1;
}

void delayForData(int waitTime) {
  osDelay(waitTime);
  /*
  if (waitTime == 0) // Wait forever
  {
    while (!getIsDataReady()) {
      delay(1);
    }
    return;
  }
  if (waitTime > 0) // Wait for that many milliseconds
  {
    uint32_t elapsedMillis = 0;
    while (!getIsDataReady() && elapsedMillis < waitTime) {
      delay(1);
      elapsedMillis++;
    }
    return;
  }
  if (waitTime < 0) {
    // For future use?
    return;
  }
  */
}

void setup_F1F4_Clear_NIR() {
  // SMUX Config for F1,F2,F3,F4,NIR,Clear
  writeRegister(byte(0x00), byte(0x30)); // F3 left set to ADC2
  writeRegister(byte(0x01), byte(0x01)); // F1 left set to ADC0
  writeRegister(byte(0x02), byte(0x00)); // Reserved or disabled
  writeRegister(byte(0x03), byte(0x00)); // F8 left disabled
  writeRegister(byte(0x04), byte(0x00)); // F6 left disabled
  writeRegister(byte(0x05), byte(0x42)); // F4 left connected to ADC3/f2 left connected to ADC1
  writeRegister(byte(0x06), byte(0x00)); // F5 left disbled
  writeRegister(byte(0x07), byte(0x00)); // F7 left disbled
  writeRegister(byte(0x08), byte(0x50)); // CLEAR connected to ADC4
  writeRegister(byte(0x09), byte(0x00)); // F5 right disabled
  writeRegister(byte(0x0A), byte(0x00)); // F7 right disabled
  writeRegister(byte(0x0B), byte(0x00)); // Reserved or disabled
  writeRegister(byte(0x0C), byte(0x20)); // F2 right connected to ADC1
  writeRegister(byte(0x0D), byte(0x04)); // F4 right connected to ADC3
  writeRegister(byte(0x0E), byte(0x00)); // F6/F8 right disabled
  writeRegister(byte(0x0F), byte(0x30)); // F3 right connected to AD2
  writeRegister(byte(0x10), byte(0x01)); // F1 right connected to AD0
  writeRegister(byte(0x11), byte(0x50)); // CLEAR right connected to AD4
  writeRegister(byte(0x12), byte(0x00)); // Reserved or disabled
  writeRegister(byte(0x13), byte(0x06)); // NIR connected to ADC5
}
void writeRegister(I2C_HandleTypeDef *hi2c1, uint8_t addr, uint8_t val) {
	uint8_t data[] = {addr, val};
	while(HAL_I2C_Master_Transmit(hi2c1, 0x72, data, sizeof(data), HAL_MAX_DELAY) != HAL_OK);
	while(HAL_I2C_IsDeviceReady(hi2c1,0x72,10,200)!=HAL_OK);

}
